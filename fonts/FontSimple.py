import re
import numpy
import sys
# numpy.set_printoptions(threshold=numpy.nan)
numpy.set_printoptions(threshold=sys.maxsize) # per https://github.com/numpy/numpy/issues/12987

class FontSimple:
    def __init__(self, data):
        self.glyphs = {}
        self.load_glyphs(data)

    # Load more glyphs from data (as if generated by scripts/genfont.pl).
    # Supersedes previous glyphs on clash.
    def load_glyphs(self, data):
        lines = [x.strip() for x in data]
        mode = "need_header"
        write_to = None
        bitmap = None
        m = None
        for line in lines:
            p = re.compile('(\d+) (\d+) (\d+)')
            regex_tuple = p.findall(line)
            if mode == "need_header" and regex_tuple:
                bitmap = []
                m = regex_tuple[0]
                write_to = {"shift_h" : m[1] , "shift_v" : m[2]}
                self.glyphs[m[0]] = write_to
                mode = "need_line"
            elif mode == "need_line":
                if not line:
                    mode = "need_header"
                    write_to["bitmap"] = bitmap
                    self.glyphs[m[0]] = write_to
                else:
                    bitmap += line.split('\n')

    # Render string given the max height above the baseline. Returns rectangular
    # array, starting from top-left corner.
    # Opts:
    #  ignore_shift_h - whether to ignore shift_h read from the font.
    #  fixed_width - make width exactly this, cropping or pannin the text to it.

    def render(self, string, height, opts = {}):

        # We'll store, temporarily, bits in buf hash where hash[[i,j]] is a bit.
        # i points up, and j points right from the start of the baseline.
        buf = {}
        width = 0

        for x in string:
            c_code = str(ord(x))
            glyph = self.glyphs[c_code]
            add_shift_h = None
            if "ignore_shift_h" in opts:
                if opts["ignore_shift_h"]:
                    add_shift_h = 0
            else:
                add_shift_h = glyph["shift_h"]
            for i, row in enumerate(glyph["bitmap"]):
                for j, bit in enumerate(row):
                    bit_row = (int(glyph["shift_v"]) - 1) - i
                    bit_col = width + j + add_shift_h
                    buf[(bit_row, bit_col)] = bit
                    if bit_row < 0:
                        print("negative value for letter %s" % c_code)
            # Compute the new width.
            if glyph["bitmap"][0]:
                width += len(glyph["bitmap"][0])
            else:
                width += 0
            # Insert interval between letters.
            width += 1 + add_shift_h

        # now render the final array
        # OLD # result = numpy.zeros(height * width,dtype=int).reshape((height, width))
        # NEW #
        height=int(height)
        result = numpy.zeros(height * width,dtype=int).reshape((height, width))

        for xy in buf:
            bit = buf[xy]
            row = (height - 1) - xy[0]
            col = xy[1]
            result[row][col] = bit


        #---------------------------------------------------------------------------------------------------------------
        # truncate array if pic is bigger than allowed for. e.g. if width > opts["fixed_width"]
        #---------------------------------------------------------------------------------------------------------------
        # Convert to list from numpy array
        new_result = []
        for row in result:
            # print result
            new_result.append(row.tolist())


        # HANDLE MESSAGES TOO LONG - TRUNCATE

        sign_width = opts["fixed_width"]

        if width > sign_width:
            print('----------------MESSAGE TOO LONG------------')
            print("initial width:", width, end=' ')
            print("/ sign width:", sign_width, end=' ')
            print("/ truncating to:", sign_width)

            for i, row in enumerate(new_result):
                slice_r = int(sign_width)
                # Slice right & pad
                sliced_row = row[:slice_r]
                new_result[i] = sliced_row

                print("new pixel row length:",len(new_result[i]))

        else:
            print("sign width:", sign_width)

        for row in new_result:
            for j, short_row in enumerate(new_result):
                expanded_row = (short_row + sign_width * [int(0)])[:sign_width]
                new_result[j] = expanded_row

        return new_result

        #---------------------------------------------------------------------------------------------------------------


    # Same as render, but renders several lines (its an array), and places them
    # below each other.  Accepts the same options as "render," and also these:
    # distance: distance between lines in pixels.
    def render_multiline(self, lines, line_height, opts = {}):
        line_pics = [self.render(line, line_height, opts) for line in lines]
        canvas = []
        for line in line_pics:
            if not line:
                return None
            canvas += line
        return canvas

def sign_font(glyphs_path):
    # Returns the default, most useful instance of the font used in signs.
    sf = FontSimple(\
            open('/'.join([glyphs_path,'7x7.simpleglyphs'])).readlines())

    # Load amendments to the letters I don't like.
    sf.load_glyphs(\
            open('/'.join([glyphs_path,'amends.simpleglyphs'])).readlines())

    # Load local, application-specific glyphs.
    sf.load_glyphs(\
            open('/'.join([glyphs_path,'specific.simpleglyphs'])).readlines())

    return sf